# -*- coding: utf-8 -*-
"""tele-bot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qFpz4d-kpVlvll6tJeY91wvyimCY29LH
"""

# import stuff for chatbot
# this doesnt work in colab : use jupyter-notebook  becuase the module win32com 
# is not available in colab
# you will need to install these for the first time usage 

import pyhibp
from pyhibp import pwnedpasswords as pw
from gtts import gTTS #Import Google Text to Speech
from IPython.display import Audio #Import Audio method from IPython's Display Class
from keras.models import Sequential
from keras.losses import categorical_crossentropy
from tensorflow.keras.optimizers import SGD
from keras.layers import Dense
from numpy import argmax
import numpy as np
import re
#re-made
import requests
import bs4
from bs4 import BeautifulSoup
import nltk # to process text data
import numpy as np # to represent corpus as arrays
import random 
import string # to process standard python strings
'''from sklearn.metrics.pairwise import cosine_similarity # We will use this later to decide how similar two sentences are
from sklearn.feature_extraction.text import TfidfVectorizer
# Remember when you built a function to create a tfidf bag of words in Experience 2? This function does the same thing!
nltk.download('punkt') # first-time use only tokenizer
nltk.download('wordnet') # first-time use only Used for the lemmatizer
'''


# start training
a_do=['what can you do?','what all can you do?','show me what you can do']
a_greets = ["hi", "hello",
            "hey", "helloo", "hellooo",
            "g morining", "gmorning",
            "good morning", "morning", "good day",
            "good afternoon", "good evening", "greetings",
            "greeting", "good to see you", "its good seeing you",
            "g’day"]
a_hows = ["how are you", "how're you", "how are you doing","how ya doin", "how is everything", "how is everything going","how are things","how're things", "how is it going", "how's it going","how's it goin'", "how's it goin", "how is life been treating you,", "hows life been treating you", "how have you been", "how've you been"]
a_whats = ["what are you doing?","what is up", "what's up", "what is cracking","what's cracking", "what is happening", "what's happening", "what is new", "what's new", "what is new"]
a_population=['what is the population of india',
              'what is the population of place',
              'what is the population',
              'name the population',
              'tottal population of country',
              'how many people in india',
              'tottal population of'
              'population of'
              'population']
a_gl = ["search google","google","check on google","go to google",
        'search for the fastest animal','search in google','got to search',
        'start search',
        'do a google search',
        'perform  a google search',
        'performa a search']
a_summary = ['summarize','summarise','can you summarize this',
               'summarise','summary',
               'summarise','write the summary',
               'give the summary',
               'summaries',
               'shorten this text',
               'shorten',
               'short',
               'summary',
               'summaries']
a_bye = ['tata','catch you later','see you later','bye','bye bye','am going','bye',
         'bye-bye','adios','cheerio','ciao','bii','bii bii']
a_weather =['what is the weather ?','how is the weather','hows weather',
            'show weather','weather']
a_game = ['can we play a game','lets play a game','would you like to play a game?','come on lets play a game',
          'play a game','start a game','time to play','play a game','lets play','play something','can we play?']
      
b_greets = ["hi", "hello",
            "hey", "helloo", "hellooo",
            "g morining", "gmorning",
            "good morning", "morning", "good day",
            "good afternoon", "good evening", "greetings",
            "greeting", "good to see you", "its good seeing you",
            "g’day", "howdy"]
a_pawned = ["have i been pawned","check pawned","pawned","have i been breached","breach","is there a data breach","check for breach",
           "am i breached","is my password safe","is my credentials secure?",
           "check credentials"]
b_hows = ["cool",'am good','awesome!','i was born cool!']

b_whats = ["listening to you","waiting for a task","nothing much"]
b_bye=['tata','catch you later','see you later','bye','bye bye',
       'adios','cheerio','ciao']
X=[]
X = a_hows + a_whats + a_greets + a_do + a_gl + a_weather + a_game + a_bye + a_population + a_pawned + a_summary
responses = b_greets + b_hows + b_whats + a_bye
Y=[]
g=['google']
C=[]
for i in X:
  if i in a_whats:
    C.append('whats')
  elif i in a_hows:
    C.append('hows')
  elif i in a_greets:
    C.append('greets')
  elif i in a_do:
    C.append('do')
  elif i in a_gl:
    C.append('google')
  elif i in a_weather:
    C.append('weather')
  elif i in a_game:
    C.append('game')
  elif i in a_bye:
    C.append('bye')
  elif i in a_population:
    C.append('population')
  elif i in a_pawned:
    C.append('pawned')
  elif i in a_summary:
    C.append('summary')
Y=C
print(X,Y,sep='\n')
print(len(X),len(Y))
print('Hii, am dex! ','what can i do for you?','you can try typing : what can you do?',sep='\n')

Y=C

# population by place

# population
def population():
  global popu
  global city
# Taking thecity name as an input from the user
  city = input("Type the name of the country/state/district :  ")
  
# Generating the url  
  url = "https://google.com/search?q=population+in+" + city
  
# Sending HTTP request 
  request_result = requests.get( url )
  
# Pulling HTTP data from internet 
  soup = bs4.BeautifulSoup( request_result.text 
                         , "html.parser" )
  
# Finding temperature in Celsius.
# The temperature is stored inside the class "BNeawe". 
  popu = soup.find( "div" , class_='BNeawe' ).text

# weather - using bs4
def weather():
  global temp
  
# Taking thecity name as an input from the user
  city = input('where are you now?  :   ')
  
# Generating the url  
  url = "https://google.com/search?q=weather+in+" + city
  
# Sending HTTP request 
  request_result = requests.get( url )
  
# Pulling HTTP data from internet 
  soup = bs4.BeautifulSoup( request_result.text ,
                           "html.parser" )
  
# Finding temperature in Celsius.
# The temperature is stored inside the class "BNeawe". 
  temp = soup.find( "div" , class_='BNeawe' ).text 
  k=''   
  kc='°C'
  for i in temp:
    if i.isdigit():
      k=k+i
  k=int(k)
  c=(k-32)*(5/9)
  c=int(c)
  c=str(c)
  temp=c+kc

def search():
  global stat
  global heading_object
  print('what do you want to search for?  ')
  text=input()
  url = 'https://google.com/search?q=' + text
  
# Fetch the URL data using requests.get(url),
# store it in a variable, request_result.
  request_result=requests.get( url )
  
# Creating soup from the fetched request
  soup = bs4.BeautifulSoup(request_result.text,
                           "html.parser")
  heading_object=soup.find_all( 'h3' )
  
# Iterate through the object 
# and print it as a string.
  for info in heading_object:
      print(info.getText())
      print("------")
  stat=heading_object

#processing


def remove_non_alpha_numeric_characters(sentence):
    new_sentence = ''
    for alphabet in sentence:
        if alphabet.isalpha() or alphabet == ' ':
            new_sentence += alphabet
    return new_sentence
    sentence=remove_non_alphanumeric_characters(sentence)
    
        
  #

def preprocess_data(X):
  X = [data_point.lower() for data_point in X]
  X = [remove_non_alpha_numeric_characters(
       sentence) for sentence in X]
  X = [data_point.strip() for data_point in X]
  X = [re.sub(' +', ' ',
              data_point) for data_point in X]
  return X
  

  #
  #pre_process
X = preprocess_data(X)
vocabulary = set()
for data_point in X:
    for word in data_point.split(' '):
         vocabulary.add(word)

vocabulary = list(vocabulary)



  #

X_encoded = []

def encode_sentence(sentence):
    sentence = preprocess_data([sentence])[0]
    sentence_encoded = [0] * len(vocabulary)
    for i in range(len(vocabulary)):
       if vocabulary[i] in sentence.split(' '):
          sentence_encoded[i] = 1
    return sentence_encoded

X_encoded = [encode_sentence(sentence) for sentence in X]


classes = list(set(Y))

Y_encoded = []
for data_point in Y:
  data_point_encoded = [0] * len(classes)
  for i in range(len(classes)):
     if classes[i] == data_point:
       data_point_encoded[i] = 1
       Y_encoded.append(data_point_encoded)


  # train data

X_train = X_encoded
y_train = Y_encoded
X_test = X_encoded
y_test = Y_encoded




  #print and check


y_train

  # model training

model = Sequential()
model.add(Dense(units=64, activation='sigmoid',
                input_dim=len(X_train[0])))
model.add(Dense(units=len(y_train[0]), activation='softmax'))
model.compile(loss=categorical_crossentropy,
              optimizer=SGD(lr=0.01,
                            momentum=0.9, nesterov=True))
model.fit(np.array(X_train), np.array(y_train), epochs=500, batch_size=16)
  
  
  #list prediction

predictions = [argmax(pred) for pred in model.predict(np.array(X_test))]


  # model evaluation

correct = 0
for i in range(len(predictions)):
    if predictions[i] == argmax(y_test[i]):
        correct += 1

print ("Correct:", correct)
print ("Total:", len(predictions))

def speech(a):
  tts=gTTS(a)
  tts.save('1.wav')
  sound_file='1.wav'
  return Audio(sound_file,autoplay=True)
sp='Hello , I am dex! what can i do for you'

def pawned():
# Required: A descriptive user agent must be set describing the application consuming
#   the HIBP API
  pyhibp.set_user_agent(ua="Awesome application/0.0.1 (An awesome description)")
  passw=input('enter a password to see if it has been breached : ')
  # Check a password to see if it has been disclosed in a public breach corpus
  resp = pw.is_password_breached(password=passw)

  if resp:
      print("Password breached!")
      print("This password was used {0} time(s) before.".format(resp))
  else:
    print("No breaches found")

  # Get data classes in the HIBP system
  resp = pyhibp.get_data_classes()

  # Get all breach information
  resp = pyhibp.get_all_breaches()

  # Get a single breach
  resp = pyhibp.get_single_breach(breach_name="Adobe")

  # An API key is required for calls which search by email address
  #   (so get_pastes/get_account_breaches)
  # See <https://haveibeenpwned.com/API/Key>
  HIBP_API_KEY = None

  if HIBP_API_KEY:
      # Set the API key prior to using the functions which require it.
      pyhibp.set_api_key(key=HIBP_API_KEY)

      # Get pastes affecting a given email address
      resp = pyhibp.get_pastes(email_address=email)

      # Get breaches that affect a given account
      resp = pyhibp.get_account_breaches(account=email, truncate_response=True)

# game
# tic tac toe
theBoard = {'7': ' ' , '8': ' ' , '9': ' ' ,
            '4': ' ' , '5': ' ' , '6': ' ' ,
            '1': ' ' , '2': ' ' , '3': ' ' }

board_keys = []

for key in theBoard:
    board_keys.append(key)

''' We will have to print the updated board after every move in the game and 
    thus we will make a function in which we'll define the printBoard function
    so that we can easily print the board everytime by calling this function. '''

def printBoard(board):
    print(board['7'] + '|' + board['8'] + '|' + board['9'])
    print('-+-+-')
    print(board['4'] + '|' + board['5'] + '|' + board['6'])
    print('-+-+-')
    print(board['1'] + '|' + board['2'] + '|' + board['3'])

# Now we'll write the main function which has all the gameplay functionality.
def game():

    turn = 'X'
    count = 0


    for i in range(10):
        printBoard(theBoard)
        print("It's your turn," + turn + ".Move to which place?")

        move = input()        

        if theBoard[move] == ' ':
            theBoard[move] = turn
            count += 1
        else:
            print("That place is already filled.\nMove to which place?")
            continue

        # Now we will check if player X or O has won,for every move after 5 moves. 
        if count >= 5:
            if theBoard['7'] == theBoard['8'] == theBoard['9'] != ' ': # across the top
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")                
                break
            elif theBoard['4'] == theBoard['5'] == theBoard['6'] != ' ': # across the middle
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['2'] == theBoard['3'] != ' ': # across the bottom
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['4'] == theBoard['7'] != ' ': # down the left side
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['2'] == theBoard['5'] == theBoard['8'] != ' ': # down the middle
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['3'] == theBoard['6'] == theBoard['9'] != ' ': # down the right side
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break 
            elif theBoard['7'] == theBoard['5'] == theBoard['3'] != ' ': # diagonal
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break
            elif theBoard['1'] == theBoard['5'] == theBoard['9'] != ' ': # diagonal
                printBoard(theBoard)
                print("\nGame Over.\n")                
                print(" **** " +turn + " won. ****")
                break 

        # If neither X nor O wins and the board is full, we'll declare the result as 'tie'.
        if count == 9:
            print("\nGame Over.\n")                
            print("It's a Tie!!")

        # Now we have to change the player after every move.
        if turn =='X':
            turn = 'O'
        else:
            turn = 'X'        
    
    # Now we will ask if player wants to restart the game or not.
    restart = input("Do want to play Again?(y/n)")
    if restart == "y" or restart == "Y":  
        for key in board_keys:
            theBoard[key] = " "

        game()

#summary

# importing libraries
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize, sent_tokenize
nltk.download('stopwords')
nltk.download('punkt')   
def fromlink():
  global text
  
  # get URL
  link=input('enter the link to the text  : ')
  page = requests.get(link)
  
  # scrape webpage
  soup = BeautifulSoup(page.content, 'html.parser')
  
  list(soup.children)
  
  # find all occurance of p in HTML
  # includes HTML tags
  soup.find_all('p')
  
  print('\n\n')
  
  # return only text
  # does not include HTML tags
  text = soup.find_all('p')[0].get_text()


def summary():
  global summary,text
  # Input text - to summarize 
  print('what do you want to summarize?')
  print('1) text ',' 2) a link to source text ',sep='\n')
  while True:

    inp=input()
    if inp=='1':
      text = input('enter the text to summarize it : ')
      break
    elif inp=='2':
      fromlink()
      break
  # Tokenizing the text
  stopWords = set(stopwords.words("english"))
  words = word_tokenize(text)
   
  # Creating a frequency table to keep the 
  # score of each word
   
  freqTable = dict()
  for word in words:
      word = word.lower()
      if word in stopWords:
          continue
      if word in freqTable:
          freqTable[word] += 1
      else:
          freqTable[word] = 1
   
  # Creating a dictionary to keep the score
  # of each sentence
  sentences = sent_tokenize(text)
  sentenceValue = dict()
   
  for sentence in sentences:
      for word, freq in freqTable.items():
          if word in sentence.lower():
              if sentence in sentenceValue:
                  sentenceValue[sentence] += freq
              else:
                  sentenceValue[sentence] = freq
   
   
   
  sumValues = 0
  for sentence in sentenceValue:
      sumValues += sentenceValue[sentence]
   
  # Average value of a sentence from the original text
   
  average = int(sumValues / len(sentenceValue))
   
  # Storing sentences into our summary.
  summary = ''
  for sentence in sentences:
      if (sentence in sentenceValue) and (sentenceValue[sentence] > (1.2 * average)):
          summary += " " + sentence
  print('length of input  : ',len(text))
  print('length of output : ',len(summary))
  input(' press enter to show the summary ')
  sumsplit=summary.split()
  for i in sumsplit:
    if '.' in i:
      print(i,end='\n')
    else:
      print(i,end=' ')

speech(sp)

# testing the chatbot
msg= 'hi'
def maina():
  global res
  print(' try typing "what can you do?"')
  while True:  
      global res
      print ("Enter a sentence")
      sentence = msg
      prediction= model.predict(np.array([encode_sentence(sentence)]))
#      print (classes[argmax(prediction)])
      cls=classes[argmax(prediction)]
 #   if 'search' or 'google' in (sentence.lower()).split():
  #    cls='google'
#    if 'game' in (sentence.lower().split or sentence.lower()):
#     cls='game'
      if cls=='bye':
        res=random.choice(b_bye)
        print(res)
        break
      elif cls == 'greets':
        res=random.choice(b_greets)
      elif cls=='hows':
        res=random.choice(b_hows)
      elif cls=='whats':
        res=random.choice(b_whats)
#        here ###################
      elif cls=='google':
        search()
        print('results from the web : ')
        res=''
        for i in stat:
          print(i.getText())
          print("------")
      elif cls=='summary' :
        summary()
        res=' ' 
      elif cls=='game':
        print('ok..lets play tic tac toe !')
        res=''
        game()
      elif cls=='weather':
        weather()
        t='the temperature in kochi is : '
        res=t + temp
      elif cls=='do':
     # print('i can play game with you ,tell the population of a country','and eve search google for you queries!','tell the weather',sep='\n')
        print("I can tell you if your password has been pawned/breached","tell you the current weather","play small games","tell the population of a place","and even search for any of your queries in google!",'just ask',sep='\n')
        res=''
      elif cls=='population':
        population()
        res='the tottal population of '+city+' is '+popu
      elif cls=='pawned':
        pawned()
        res=''
      
      res=str(res)
      break
      

sp='it was nice chatting with you.  ' + random.choice(b_bye)

#Audio(sound_file,autoplay=True)


#  token

token = "2104254066:AAF3VIPgTmt9nvu6lyBlmUyrlZOR8KvPwr0"


#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This program is dedicated to the public domain under the CC0 license.

"""
Simple Bot to reply to Telegram messages.

First, a few handler functions are defined. Then, those functions are passed to
the Dispatcher and registered at their respective places.
Then, the bot is started and runs until we press Ctrl-C on the command line.

Usage:
Basic Echobot example, repeats messages.
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

import logging

from telegram.ext import Updater, CommandHandler, MessageHandler, Filters

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO)

logger = logging.getLogger(__name__)


# Define a few command handlers. These usually take the two arguments update and
# context. Error handlers also receive the raised TelegramError object in error.
def start(update, context):
    """Send a message when the command /start is issued."""
    update.message.reply_text('Hi!, Nice to meet you!')


def help(update, context):
    """Send a message when the command /help is issued."""
    update.message.reply_text('Help!')


def echo(update, context):
    """Echo the user message."""
    print(update.message.text)
    global msg
    msg = update.message.text
    maina()
    update.message.reply_text(res)


def error(update, context):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, context.error)


def main():
    """Start the bot."""
    # Create the Updater and pass it your bot's token.
    # Make sure to set use_context=True to use the new context based callbacks
    # Post version 12 this will no longer be necessary
    updater = Updater(token, use_context=True)

    # Get the dispatcher to register handlers
    dp = updater.dispatcher

    # on different commands - answer in Telegram
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("help", help))

    # on noncommand i.e message - echo the message on Telegram
    dp.add_handler(MessageHandler(Filters.text, echo))

    # log all errors
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()


if __name__ == '__main__':
    main()



